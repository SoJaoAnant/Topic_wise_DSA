MI BABA'S TRI TRI DSA QUESTIONS :3

ARRAYS
1.	Set matrix zeroes (donenzo)
2.	Pascal’s triangle (donenzo)
3.	Next permutation (donenzo)
4.	Kadane’s algorithm (donenzo)
5.	Sort an array of 0s 1s 2s (donenzo)
6.	Stock buy and sell

ARRAYS-2
1.	Rotate matrix
2.	Merge overlapping subintervals
3.	Merge two sorted arrays without extra space
4.	Find the duplicate in an array of n+1 integers
5.	Repeat and missing number
6.	Inversion of array (pre req: merge sort)

ARRAY-3
1.	Search in a 2d matrix
2.	pow(x, n)
3.	Majority element (>n/2)
4.	Majority element (n/3 times)
5.	Grid unique paths
6.	Reverse pairs

ARRAY-4
1.	2 sum
2.	4 sum
3.	Longest consecutive sequence
4.	Largest subarray with k sum
5.	Count number of subarrays with given xor k
6.	Longest substring without repeat

 LINKED LIST
1.	Reverse a linked list
2.	Find the middle of linked list
3.	Merge two sorted linked list
4.	Remove nth node from back of linked list
5.	Ass two numbers as linked list
6.	Delete a given node when a node is given

LINKED LIST-2 
1.	Find intersection point of Y linked list
2.	Detect a cycle in linked list
3.	Reverse a linked list in groups of size k
4.	Check if a linked list is palindrome or not
5.	Find the starting point of the loop of linked list
6.	Flattening of a linked list 

LINKED LIST AND ARRAYS
1.	Rotate a linked list
2.	Clone a linked list with random and next pointer
3.	3 sum
4.	Trapping rainwater
5.	Remove duplicate from sorted array
6.	Max consecutive ones

GREEDY ALGORITHM
1.	N meetings in one room
2.	Minimum numbers of platforms required for a railway
3.	Job sequencing problem
4.	Fractional knapsack problems
5.	Greedy algo to find minimum number of coins
6.	Assign cookies

RECURSION
1.	Subset sums
2.	Subset 2
3.	Combination sum 1
4.	Combination sum 2
5.	Palindrome partitioning
6.	Kth permutation sequence

RECURSION AND BACKTRACKING
1.	Print all permutations of a string.array
2.	Nqueens
3.	Sudoku solver
4.	M coloring problem
5.	Rat in a maze
6.	Word break

BINARY SEARCH
1.	The nth root of an integer
2.	Matrix median
3.	Find the element that appears once in a sorted array, and the rest appears twice
4.	Search element in a sorted and rotated array. Find pivot where it is rotated
5.	Median of 2 sorted arrays
6.	Kth element of two sorted arrays
7.	Allocate minimum numbers of pages
8.	Aggressive cows

HEAPS
1.	Max heap, min heap implementation
2.	Kth largest element
3.	Maximum sum combination
4.	Find median from data stream
5.	Merge k sorted arrays
6.	K most frequent elements

STACK AND QUEUES
1.	Implement stack using arrays
2.	Implement queue using arrays
3.	Implement stack using queue (using single queue)
4.	Implement queue using stack (O(1) amortyized method)
5.	Check for balanced parentheses
6.	Next greater element
7.	Sort a stack

STACK AND QUEUES-2
1.	Next smaller element
2.	LRU cache
3.	LFU cache
4.	Largest rectangle in a histogram
5.	Sliding window maximum
6.	Implement min stack
7.	Rotten orange
8.	Stock span problem 
9.	Find the maximum of  minimums of every window size
10.	The celebrity problem

STRING
1.	 Reverse words in a string
2.	Longest Palindrome in a string
3.	Roman Number to Integer and vice versa
4.	Implement ATOI/STRSTR
5.	Longest Common Prefix
6.	Rabin Karp

STRING-2
1.	Z-Function
2.	KMP algo / LPS(pi) array
3.	Minimum characters needed to be inserted in the beginning to make it palindromic
4.	Check for Anagrams
5.	Count and say
6.	Compare version numbers

BINARY TREE
1.	Inorder traversal
2.	Preorder traversal
3.	Postorder traversal
4.	Morris Inorder Traversal
5.	Morris Preorder Traversal
6.	LeftView Of Binary Tree
7.	Bottom View of Binary Tree
8.	Top View of Binary Tree
9.	Preorder inorder postorder in a single traversal
10.	Vertical order traversal
11.	Root to Node Path in Binary Tree
12.	Max width of a Binary Tree

BINARY TREE-2
1.	Level order Traversal / Level order traversal in spiral form
2.	Height of a Binary Tree
3.	Diameter of Binary Tree
4.	Check if the Binary tree is height-balanced or not
5.	LCA in Binary Tree
6.	Check if two trees are identical or not
7.	Zig Zag Traversal of Binary Tree
8.	Boundary Traversal of Binary Tree

BINARY TREE-3
1.	Maximum path sum
2.	Construct Binary Tree from inorder and preorder
3.	Construct Binary Tree from Inorder and Postorder
4.	Symmetric Binary Tree
5.	Flatten Binary Tree to LinkedList
6.	Check if Binary Tree is the mirror of itself or not
7.	Check for Children Sum Property

BINARY SEARCH TREE
1.	Populate Next Right pointers of Tree
2.	Search given Key in BST
3.	Construct BST from given keys
4.	Construct a BST from a preorder traversal
5.	Check is a BT is BST or not
6.	Find LCA of two nodes in BST
7.	Find the inorder predecessor/successor of a given Key in BST.

BINARY SEARCH TREEE-2
1.	Floor in a BST
2.	Ceil in a BST
3.	Find K-th smallest element in BST
4.	Find K-th smallest element in BST
5.	Find a pair with a given sum in BST
6.	BST iterator
7.	Size of the largest BST in a Binary Tree
8.	Serialize and deserialize Binary Tree

BINARY TREE MISC
1.	Binary Tree to Double Linked List
2.	Find median in a stream of running integers.
3.	K-th largest element in a stream.
4.	Distinct numbers in Window.
5.	K-th largest element in an unsorted array.
6.	Flood-fill Algorithm

GRAPH
1.	Clone a graph
2.	DFS
3.	BFS
4.	Detect a cycle in an undirected graph using bfs
5.	Detect A cycle in Undirected Graph using DFS
6.	Detect A cycle in a Directed Graph using DFS
7.	Detect A cycle in a Directed Graph using BFS
8.	Topological Sort BFS
9.	Topological Sort DFS
10.	Number of islands(Do in Grid and Graph Both)
11.	Bipartite Check using BFS
12.	Bipartite Check using DFS

GRAPH-2
1.	Strongly Connected Component(using KosaRajuΓÇÖs algo)
2.	DijkstraΓÇÖs Algorithm
3.	Bellman-Ford Algo
4.	Floyd Warshall Algorithm
5.	MST using Prim's Algo
6.	MST using KruskalΓÇÖs Algo

DP
1.	Max Product Subarray
2.	Longest Increasing Subsequence
3.	Longest Common Subsequence
4.	0-1 Knapsack
5.	Edit Distance
6.	Maximum sum increasing subsequence
7.	Matrix chain multiplication

DP-2
1.	Minimum sum path in the matrix, (count paths and similar type do, also backtrack to find the Minimum path)
2.	Coin change
3.	Subset sum
4.	Rod cutting
5.	Egg dropping
6.	Word break
7.	Palindrome partitioning (MCM variation)
8.	Maximum profit in job scheduling

TRIE
1.	Implement Trie (Prefix Tree)
2.	Implement Trie - 2 (Prefix Tree)
3.	Longest String with All Prefixes
4.	Number of Distinct Substrings in a String
5.	Power Set (this is very important)
6.	Maximum XOR of two numbers in an array
7.	Maximum XOR With an Element From Array
